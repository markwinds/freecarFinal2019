# 模块的功能分析

## 系统的协调控制
- 中断的优先级设定

## UI的设计
- 按键控制的状态转移
- 变量值的在线更改
- 变量值与图像同时显示并将更改的结果展示在图像上
- 图片的flash存储
- 处理图片的查看
- 命令行

## 舵机的控制算法
- 通过pid的调控，使得舵机能达到快速反应而且不震荡
- 偏差与打角的关系
    - 通过处理图像得到边缘
    - 分别取出两个连续的赛道边的3个点
    - 将总共6点的坐标进行梯形校正得到其实际的坐标位置（即真实世界的一个弯道，不管摄像头从远还是近观察，其曲率不变）
    - 通过算法得到边缘的连续关系
    - 计算出目标弯道的曲率
    - 推算曲率和真实弯道半径的关系
    - 推算真实弯道半径和舵机打角的关系
    - 推算舵机打角和pwm占空比的关系
    - PD P随偏差二次增大 D不变
    - 随速度动态的选取行
    - 左右转的舵机PD不同
    - 不同赛道用不同的PD
    - 加入一个参数为远行偏差和近行偏差的差，将其乘上一个常数后加到最后的舵机偏差中，这样过s弯可以抄近道
    - 将图像按行分为6段，得出每一段的斜率加权得到最后的斜率
    - 走两边的斜率转折点通过小S弯

## 电机的控制算法

## 图像的处理算法
- 通过摄像头获取图像
- 透视变换与桶形失真








# 模块的功能实现

## 系统架构的实现

### 中断优先级的设置
- [怎么设置中断的优先级](http://www.vcan123.com/forum.php?mod=viewthread&tid=959&highlight=%D3%C5%CF%C8%BC%B6)

| 中断                 | 中断类型         | 中断优先级 |
|--------------------|------------------|------------|
| 命令行的中断         | UART4_RX_TX_IRQn | 3          |
| LCD的按键中断        | PORTD_IRQn       | 4          |
| 摄像头的DMA中断      | DMA0_IRQn        | 5          |
| 摄像头的场中断       | PORTA_IRQn       | 6          |
| 编码器的中断         | PIT0_IRQn        | 7          |
| 摄像头的采集图片中断 | PIT1_IRQn        | 8          |

## UI的实现

### 通过串口实现命令行控制
- 命令行在代码中的实现
    - uart串口部分负责识别是否有命令输入，有就将uart4_to_do_flag置1
    - waitToDo部分判断uart4_to_do_flag是否置1而确定是否开始解析命令
    - command文件负责解析并执行命令
- 命令的首位是否需要特殊字符 不需要，只要每个命令都用回车结尾就行了
- 怎样实现命令行参数个数的识别
    - strtok分割函数
        - [strtok函数的使用](https://blog.csdn.net/buaa_shang/article/details/8189984)
        - [strtok函数的讲解](https://blog.csdn.net/weibo1230123/article/details/80177898)
        >对于strtok_r函数，如果第1个参数为NULL，就会从第3个参数开始（相当于第1个参数位置填入第3个参数）
    - sprintf
    - 将所有的命令简写为两个字符
- 怎样解析并执行命令
    -直接用switch语句

### flash的实现
每次扇区写入4字节,数据地址每加一移动1个字节，因为程序里乘4，所以sector_offset加一，偏移4个字节
将图片的32个像素压缩一次写入4个字节
一幅图像占用的大小：60*80/8=600字节


芯片     | 每个扇区的字节数 | 扇区数
---------|------------------|----
MK60DZ10 | 2 * 1024         | 256
MK60F15  | 4 * 1024         | 128

主要通过3个变量来记录和控制flsah的操作
int picture_num = 0;	  //存储图片的数量
int picture_now_id = 0;   //当前的图片id,id从0开始
int picture_write_id = 0; //写入图片时，为图片分配的id



## 图像处理算法的实现

### 摄像头获取图像
- 查看手册
- 直接参考别人代码提升性能
- 看山外的论坛
    - [山外论坛](http://www.vcan123.com/forum.php)
    - [山外鹰眼解压时间](http://www.vcan123.com/forum.php?mod=viewthread&tid=13652&ctid=6)
    - [山外整合资料](./source/K60中文资料整合版.pdf)
- 为什么PORTA_ISFR是写1来清标志位 因为这个寄存器是写1清0的，往里面写1赋值0
- 摄像头的代码
    - 图像的获取和处理都应该放在中断里
    - LCD的显示可以用预编译的手段放在摄像头的中断函数里面
    - 通过while来测试处理一张图片和处理一张图片并显示用的时间，再加一点时间作为中断的时间
    - 中断怎么用
        - 查看中断的例程
    - 采集一幅图像的时间长不长
        - 是采集的速度快还是将采集好的数组备份一份速度快

### 摄像头图像的解压
NULL   | 黑 | 白
-------|----|--
摄像头 | 1  | 0
解压   | 0  | 1
压缩   | 1  | 0

所以送往LCD的都是1是黑，0是白
处理的时候用的都是解压的，所以1是白，0是黑
LCD_Img_Binary 将1解析成黑 0解析成白

### 梯形校正与桶形失真
- 车子拍照传回电脑生成图片
- 编写桶形失真的代码 [桶形失真校正](https://blog.csdn.net/hyanglu1573/article/details/12876727)
    - 计算转化参数
        - 构建一个和原图大小相同的矩阵真图
        - 循环遍历真图的像素点，找出其对应于原图的位置
        - 调整参数，直到真图的直线不弯
    - 得出桶形失真的校正表
        - 测试出最小反向校正表
        - 构建一个比原图大的真图，反向映射到原图，得到60*80校正表
- 编写梯形校正的代码
    - 合并桶形失真的代码
    - 读取图片
    - 将图片转化到84*112矩阵
    - 求出透视变换矩阵
    - 显示透视变换处理后的图片
    - 生成校正表和反校正表并测试其正确性
- 合并两个校正表得到一个最后的校正表（输入一个图像点的坐标，得到一个真实世界中的坐标）



# 新知识的补充

- [sobel算子的原理讲解](https://blog.csdn.net/aiailab/article/details/82849158)
将像素点的数值看成是一个关于坐标的函数f(x,y),则函数有两个偏导
$$
\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}
$$
对于一个二维的平面来说，数值变化最快的方向是两个导数向量相加的方向，并且大小是
$$
\sqrt{\left(\frac{\partial f}{\partial x}\right)^{2}+\left(\frac{\partial f}{\partial y}\right)^{2}}
$$

- 滤波器
一幅图像包含着很多的信号，有高频也有低频，图片用黑白像素点表示
当图像中的一点翻转的时候代表这个信号分量被消除
图像中颜色一样的光斑聚集代表低频分量，颜色分散为高频分量
filter在滤波的时候
ans=src代表低通滤波器
ans=-src代表高通滤波器

@import "./source/pic/滤波器.png"

- Mat
浅层拷贝：Mat B=A；B就是浅层拷贝A,B只拷贝了A的的头部和地址，当B被操作后A也随之改变。
深层拷贝：Mat A=imread("x.jpg"); Mat B=A.clone()；B是开辟了新的内存完全的复制了A的内容，操作B不会对A造成影响。

# 自己的一些心得

## 函数的宏定义
函数的宏定义可以设置函数的默认参数
> #define readPictureToLCDDefault() readPictureToDisplayer(picture_now_id, LCD)
指针的数组应用
> #define ans(i, j) (*(ans + 80 * (i) + (j)))
注意这里的80是列的数量，并且参数i,j都要加上括号(其实只有i是必须加的)
如果i出入的参数是a+1,没加括号则先执行80*a,就出错了

## 强制类型转化
同等存储长度的转化                    | 长转短               | 短转长
-----------------------------|-------------------|------------------
存储的数据完全不变，只是解析的方式不同 | 直接截取最后几位赋值 | 不是简单的加0，还包含符号位的传递

### opencv
[opencv配置技巧](https://blog.csdn.net/mars_xiaolei/article/details/78759041#commentBox)
[opencv配置新版](https://blog.csdn.net/weixin_42274148/article/details/85321091)







## 除了单纯的调车我学会了什么
- 高效学习新知识的能力
- 快速debug的能力
- 创造开发工具的能力
- 系统分析和规划的能力
- 改善或者消除重复工作中低效率的能力
## 增加一对c和h文件时应注意
- h文件的ifdef要更改
- include文件要更新
- .c文件要加入工程
- .c的函数要在.h中声明
- 在主函数中加入代码块的初始化
## 函数找不到定义或声明
- go to definition 看看头文件里有没有全局的定义
- 看一下对应的c文件有没有这个函数
- 看一下对应的c文件有没有加入到工程


- [unreachable code 错误解决办法](https://blog.csdn.net/majishushu/article/details/53262727)

- [浮点数文件](./Chip/src/IAR/system_MK60DZ10.c)50行
## 函数指针和指针函数
注意指针函数与函数指针表示方法不同，千万不要混淆。最简单的辨别方式就是看函数名前面的指针*号有没有被括号（）包含，如果被包含就是函数指针，反之则是指针函数。
> 一个指针函数的例子，函数的返回值是指针
float *match();
float *p;
p = match(a);

函数指针图解
@import "./source/pic/函数指针.jpg"
# 新的想法
- 拒绝浮点数的运算
- PID的理解
    - 输入值和输出值需为同一量纲，这样才能进行加减得出error
    - pwm波和v的2次或者4次成线性关系
- 图像处理时，解压的时候直接生成处理后的图像，因为索引耗时
- 所有计算可以换成位操作的全部换成位操作











# 接下来应该要做什么
- 通过学习掌握用pid调控舵机
    - 网课信号与系统
    - 网课自动控制理论


# 草稿


- 桶形失真
    - 桶形失真还原的自动检测和参数自动整定
        - 扫描特定的行和列，得到3点计算曲率，当曲率小于某个值（或者半径大于某个值），就得到整定好的参数
    - 只将部分校正后的图像进行梯形校正的方法
        - 选取图像中的4个点算出转化矩阵
        - 取出要转化图像部分的4个顶点，进行梯形校正


- 梯形校正
    - 计算转化矩阵的简化方法
        - 只要知道图像中4个点和实际中4个点的坐标对应关系，就能确定一个梯形校正的转化矩阵
        - 找点的方法要注意，如果取图像的4个顶点则对应的真实世界中的坐标难以测量，所以取真实世界中的一个矩阵（方形）这样的话只要找出图像中对应的4个点的坐标就行了，这样就能轻松得到转化矩阵
    - 转化后图像的呈现
        - 利用上述方法得到的转化矩阵将图像投影到真实世界后存在坐标为负的情况
        - 解决的方法很简单，只要记录最小的坐标值（就是x,y分别的最小值），最后将图像整体平移一下显示就好了


- 小车需要做什么准备
    - 拍一张方形的图片
    >注意拍出的图片的顶部线必须为一条直线，不能有弯曲和毛刺
    - 如果想保证得到实际的坐标和真实值完全一样而不是比例关系，测量方形的边长（其实没有必要，只要有比例关系就行了）30cm


- 程序的编写
    - 怎么找出每条边的边缘点
        - 从中部选取一个点往上扫到黑点，再往下往两边扫，出现路宽变窄后竖着扫
        - 怎么查看左右边和下边边缘是否正确
            - 查看产生的边缘图片可以编写一个查看图片的函数，输入为图片的维度和图片数组、输出图片的大小，输出一幅大图
    - 怎么得到对应k值下点的新坐标
        - 建一个行数和列数都是原图3倍的图
        - 将大图根据参数映射到原图
        - 取所有映射到该点的坐标平均值为该点的新坐标
    - 怎么判断一系列点的线性度
        - [opencv直线拟合](https://blog.csdn.net/liyuanbhu/article/details/50193947)
        - 直接选取3点判断斜率
    - 查找出角落的4点
        - 顶部的两个点是触顶以后往两边扫到的点
        - 底部的两个点是路宽变窄处的两个点
    - 得到转化矩阵
    - 将要转化的范围的4个顶点转化
    - 显示图片

    >值得注意的是，图片的显示和求解转化表并没有直接的关系，决定转化表的是K值和梯形校正的转化矩阵，图片显示相当于将K值和转化矩阵展示出来。所以显示图片的时候并不需要将所有的点进行转化，而生成校正表的时候则是将所有的点都进行转化。
    - 图片的显示
        - 边缘图的显示：将小图等比例映射到一个大图
        - B图的显示：放一块大画布，将图片映射在上面
        - P图的显示：从B图中挑出要转化的区域，将其映射到P图
    - 校正表的生成
        - 将B大图映射到60*80的矩阵B_point，然后求各个点的平均坐标
        - 将B_point中的每个点通过转化矩阵转化为在P图中坐标，并pushback到P_point中
        - 将P_point打印出来就是校正表


AT+CIPMODE=1 设置为透传

AT+SAVETRANSLINK=1,"192.168.6.110",1002,"TCP"



- [TCP和UDP的区别](https://zhuanlan.zhihu.com/p/24860273)




- 电磁的调试
    - 滤波
    - 怎么采集到值
        - 中断优先级
        - 时间间隔
    - 怎么处理值
        - 差和比
    - 得到偏差
        - 线性


- 电磁测试只用中间的电感
    - 得出感值和偏离度的线性关系
    - pid控制


- 校赛的任务
    - 电磁
        - 设计一个可以看电感值的UI
        - 跑圆环
            - 加蜂鸣器代码
            - 观察电感在弯道和圆环有什么不同
            - 增加一个用于道路状态控制的文件
            - 进圆环
                - 圆环状态保护时间200ms
                    - 结构体增加一个中断的处理函数
                    - 写一个函数用来管理PT0
                        - 退出定时器时要关闭定时器、清标志位、清状态保护
                    - 设置优先级
                - 状态保护不存在时，在waitToDo里将道路状态重置为直道（在保护位撤销10个周期后如果还没有新的状态就重置）
                - 进入圆环状态判别前一个状态是否是(左)圆环，如果是则强打舵机200ms
                - 在保护时间内只靠中间的电感来判别
                - 中断的执行关系
                    - 在UI的按键中断里，在中断的执行中加入延时10s。测试按按键5次，看按键的中断函数执行了几次
                - 定时器一开启就进入中断的原因
                    - 直接操作PIT寄存器的中断允许位来完成，通过系统使能中断有点问题
            - 参考红树伟业
                - 进圆环
                    - 横向3电感值变大
                    - 数值电感值足够大且相差小
                - 跑圆环
                    - 用内侧的两个电感差比和？？？是为了比较平稳的进圆环吗
                - 出圆环
            - 怎么平稳入圆
                - 进左圆环往右抖
                    - 一判后就直行
                - 二判条件太紧，导致没有识别或者晚识别
                    - 放宽垂直电感值条件

        - 差速的方法
        - 找出一个在直道不抖，在弯道反应够快的方法
        - 归一化的作用，不用调放大器，用UI改参数
    - 摄像头
        - 将梯形校正和曲率的计算结合
        - 判断元素
        - 动态pid
    - 结合
        - 设计整体的架构
        - 设计中断和中断的时间间隔
        - 设计电磁的优先级
        - 解决小S弯






- 道路状态控制
    - 1个保护位
        - 保护位用来保护道路的状态，每个状态都有一个自己的保护时间（可以为0）
    - 2个定时器
        - PIT0用来计时保护时间
        - PIT2用来计时清空道路状态（与其他模块共用），在中断函数里累加一个数来计时。当保护位置0时计数，当保护位为1时清空计数值。当计数到一定值时，初始化道路为直道。
    - 3个事件
        - enter:进入该状态时执行的操作
        - exit:退出该状态时执行的操作
        - interrupt：当保护时间结束时执行的操作

- 代码实现
    - 将PT0的中断服务设置为一个固定的函数（包含重置定时器），并在这个函数里面执行当前状态的中断函数
    - PT2
        - 设置优先级
        - 开启中断
        - 编写中断服务函数
    - 测试实现


- 小目标
    - 出圆环
        - 当3个电感和大于2600，打角延时
    - 小s



- 重构道路类型判断
    - 进入状态，并在一定时间内使能下一阶段的检测
    - 先编写judgeRoadFromADC函数
        - 更新路况加一个判断，now_road_state==?
        - 在某个路况下要执行特殊操作：if(now_road_state==?)
    - 更改结构体，只保留enter out time
    - 写更新路况的函数
    - 写定时器更新的函数，并关闭定时器2



- 编写归一化
    - 电感值归一化的计算
        - 实测的电感值峰值应该控制在500（1024/2）左右（没有硬性的要求），因为圆环处电感值可能是峰值的两倍，要保证在量程内
        - 计算出电感归一化值 ans=1000*(测量值-55)/(峰值-55) if ans<1 ans=1;
    - UI的编写
        - 左键刷新出整个界面
            - 刷新选择点的位置
            - 刷新采集值
            - 刷新变量名
            - 刷新最大值
            - 刷新归一化值
        - 编写上下键的功能
            - 定义一个变量
            - 画框框
        - 编写左键功能
            - 将当前的测量值写入为最大值
        - 编写右键功能
            - 将数据写入flash
    - flash的存取
        - 在系统启动时将数据加载到最大值数组

- 圆环
    - 测试只用一边电感跑的效果
    - 左环检测标志
    - 用左边和中间的电感跑
    - 用左边的垂直和水平跑





- 611早上的任务
    - 检测归一化
        - 直接让车在放大器状态不同的时候跑
    - 入环
        - 阶段1
            - 标志：mid+hl>2200
            - 操作：if() offset=-45
        - 阶段2
            - 标志：mid+hl<1400
            - 操作：if() offset=-45
        - 阶段3
            - 标志：mid>1500
            - 操作：if() offset=-45
        - 测试满量程和不满量程两种谁的入环跑的好

    - 出环
        - 看出环是否需要写









- 改善电磁的UI
    - 中键
    - 


    https://github.com/markwinds/freecarFinal2019.git
    git@markwinds.github.com:markwinds/freecarFinal2019.git